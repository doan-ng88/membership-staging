<!-- Generated by Cursor -->
<template>
  <Modal
    :open="visible"
    :title="isEdit ? t('level.actions.edit') : t('level.actions.add')"
    @cancel="handleCancel"
    @ok="handleOk"
    :confirmLoading="loading"
    :okText="isEdit ? t('level.actions.update') : t('level.actions.add')"
    :cancelText="t('level.actions.cancel')"
    :maskClosable="false"
    class="level-modal"
  >
    <Spin :spinning="loading">
      <Form
        :model="formState"
        :rules="rules"
        ref="formRef"
        layout="vertical"
      >
        <!-- Name Field -->
        <FormItem 
          :label="t('level.fields.name.label')" 
          name="Name"
          :validateStatus="errors.Name ? 'error' : ''"
          :help="errors.Name"
          required
        >
          <Input 
            v-model:value="formState.Name" 
            @blur="validateField('Name')"
            :placeholder="t('level.fields.name.placeholder')"
            class="custom-input"
          />
        </FormItem>

        <!-- Rank Field -->
        <FormItem 
          :label="t('level.fields.rank.label')" 
          name="rank"
          :validateStatus="errors.rank ? 'error' : ''"
          :help="errors.rank"
          required
        >
          <InputNumber 
            v-model:value="formState.rank"
            :min="0"
            class="w-full custom-input"
            @blur="validateField('rank')"
            :placeholder="t('level.fields.rank.placeholder')"
          />
        </FormItem>

        <!-- Threshold Amount Field -->
        <FormItem 
          :label="t('level.fields.thresholdAmount.label')" 
          name="thresholdAmount"
          :validateStatus="errors.thresholdAmount ? 'error' : ''"
          :help="errors.thresholdAmount"
          required
        >
          <InputNumber
            v-model:value="formState.thresholdAmount"
            :min="0"
            class="w-full custom-input"
            @blur="validateField('thresholdAmount')"
            :formatter="value => `${value}`.replace(/\B(?=(\d{3})+(?!\d))/g, ',')"
            :parser="value => value!.replace(/\$\s?|(,*)/g, '')"
            :placeholder="t('level.fields.thresholdAmount.placeholder')"
          />
        </FormItem>

        <!-- Duration Field -->
        <FormItem 
          :label="t('level.fields.duration.label')" 
          name="durationExpired"
          :validateStatus="errors.durationExpired ? 'error' : ''"
          :help="errors.durationExpired"
          required
        >
          <InputNumber
            v-model:value="formState.durationExpired"
            :min="1"
            :max="12"
            class="w-full custom-input"
            @blur="validateField('durationExpired')"
            :placeholder="t('level.fields.duration.placeholder')"
          />
        </FormItem>

      </Form>
    </Spin>
  </Modal>
</template>

<script lang="ts" setup>
import { ref, watch } from 'vue';
import { 
  Modal,
  Form,
  FormItem,
  Input,
  InputNumber,
  message,
  Spin
} from 'ant-design-vue';
import { ExclamationCircleOutlined } from '@ant-design/icons-vue';
import { createVNode } from 'vue';
import type { FormInstance } from 'ant-design-vue';
import { type LevelSetting, defaultFormState } from '@/api/types/levelUpDownRules';
import { useLevelSettingStore } from '@/stores/levelUpDownRules';
import { levelUpDownRulesApi, ApiError } from '@/api/services/levelUpDownRulesApi';
const levelSettingStore = useLevelSettingStore();
import { useI18nGlobal } from '@/i18n';

const { t, locale: currentLocale } = useI18nGlobal();

// Props
const props = defineProps<{
  visible: boolean;
  isEdit: boolean;
  initialData?: LevelSetting;
  websiteId: number;
}>();

const emit = defineEmits<{
  (e: 'update:visible', value: boolean): void;
  (e: 'submit', data: LevelSetting): void;
  (e: 'success'): void;
}>();

const modal = Modal.useModal();
const loading = ref(false);
const formRef = ref<FormInstance>();
const formState = ref<LevelSetting>({ ...defaultFormState });
const errors = ref<Record<string, string>>({});

// Validation rules
const rules = {
  Name: [
    { required: true, message: t('level.validation.name.required') },
    { max: 50, message: t('level.validation.name.maxLength') }
  ],
  rank: [
    { required: true, message: t('level.validation.rank.required') },
    { type: 'number', min: 0, message: t('level.validation.rank.min') }
  ],
  thresholdAmount: [
    { required: true, message: t('level.validation.thresholdAmount.required') },
    { type: 'number', min: 0, message: t('level.validation.thresholdAmount.min') }
  ],
  durationExpired: [
    { required: true, message: t('level.validation.duration.required') },
    { type: 'number', min: 1, max: 12, message: t('level.validation.duration.max') }
  ]
};

// Validation functions
const validateField = async (field: string) => {
  errors.value[field] = '';
  
  switch (field) {
    case 'Name':
      if (!formState.value.Name.trim()) {
        errors.value.Name = t('level.validation.name.required');
        return false;
      }
      if (formState.value.Name.length > 50) {
        errors.value.Name = t('level.validation.name.maxLength');
        return false;
      }
      const nameExists = await levelUpDownRulesApi.checkNameExists(
        props.websiteId,
        formState.value.Name,
        props.isEdit ? formState.value.id : undefined
      );
      if (nameExists) {
        errors.value.Name = t('level.validation.name.exists', { name: formState.value.Name });
        return false;
      }
      break;

    case 'rank':
      if (formState.value.rank === null || formState.value.rank === undefined) {
        errors.value.rank = t('level.validation.rank.required');
        return false;
      }
      const rankExists = await levelUpDownRulesApi.checkRankExists(
        props.websiteId,
        formState.value.rank,
        props.isEdit ? formState.value.id : undefined
      );
      if (rankExists) {
        errors.value.rank = t('level.validation.rank.exists', { rank: formState.value.rank });
        return false;
      }
      break;

    case 'thresholdAmount':
      if (!formState.value.thresholdAmount) {
        errors.value.thresholdAmount = t('level.validation.thresholdAmount.required');
        return false;
      }
      if (formState.value.thresholdAmount < 0) {
        errors.value.thresholdAmount = t('level.validation.thresholdAmount.min');
        return false;
      }
      break;

    case 'durationExpired':
      if (!formState.value.durationExpired) {
        errors.value.durationExpired = t('level.validation.duration.required');
        return false;
      }
      if (formState.value.durationExpired < 1 || formState.value.durationExpired > 12) {
        errors.value.durationExpired = t('level.validation.duration.max');
        return false;
      }
      break;
  }
  
  return true;
};

const validateName = async () => {
  errors.value.Name = '';
  
  if (!formState.value.Name.trim()) {
    errors.value.Name = t('level.validation.name.required');
    return false;
  }

  if (formState.value.Name.length > 50) {
    errors.value.Name = t('level.validation.name.maxLength');
    return false;
  }

  // Kiểm tra tên trùng lặp
  try {
    const nameExists = await levelUpDownRulesApi.checkNameExists(
      props.websiteId,
      formState.value.Name,
      props.isEdit ? formState.value.levelId : undefined
    );
    if (nameExists) {
      errors.value.Name = t('level.validation.name.exists', { name: formState.value.Name });
      return false;
    }
  } catch (error) {
    console.error('Error checking name:', error);
    errors.value.Name = t('level.validation.name.error');
    return false;
  }

  return true;
};

const validateRank = async () => {
  errors.value.rank = '';

  if (formState.value.rank === null || formState.value.rank === undefined) {
    errors.value.rank = t('level.validation.rank.required');
    return false;
  }

  if (formState.value.rank < 0) {
    errors.value.rank = t('level.validation.rank.min');
    return false;
  }

  // Kiểm tra rank trùng lặp
  try {
    const rankExists = await levelUpDownRulesApi.checkRankExists(
      props.websiteId,
      formState.value.rank,
      props.isEdit ? formState.value.levelId : undefined
    );
    if (rankExists) {
      errors.value.rank = t('level.validation.rank.exists', { rank: formState.value.rank });
      return false;
    }
  } catch (error) {
    console.error('Error checking rank:', error);
    errors.value.rank = t('level.validation.rank.error');
    return false;
  }

  return true;
};

// Thêm watch để validate khi giá trị thay đổi
watch(() => formState.value.Name, () => {
  validateName();
}, { debounce: 300 });

watch(() => formState.value.rank, () => {
  validateRank();
});

const validateForm = async () => {
  const nameValid = await validateName();
  const rankValid = await validateRank();
  
  // Validate các trường khác
  let isValid = nameValid && rankValid;
  
  if (!formState.value.thresholdAmount && formState.value.thresholdAmount !== 0) {
    errors.value.thresholdAmount = t('level.validation.thresholdAmount.required');
    isValid = false;
  }

  if (!formState.value.durationExpired) {
    errors.value.durationExpired = t('level.validation.duration.required');
    isValid = false;
  }

  return isValid;
};

const { confirm } = Modal;

const handleOk = () => {
  if (props.isEdit) {
    confirm({
      title: t('level.actions.confirmUpdate'),
      icon: createVNode(ExclamationCircleOutlined),
      content: t('level.actions.confirmUpdateContent'),
      async onOk() {
        try {
          loading.value = true;
          // Validate trước khi cập nhật
          if (!await validateForm()) {
            return;
          }

          const payload: LevelSetting = {
            ...formState.value,
            websiteId: props.websiteId,
          };

          const success = await levelSettingStore.updateLevel(payload);
          if (success) {
            message.success(t('level.actions.updateSuccess'));
            emit('submit', payload);
            emit('success');
            emit('update:visible', false);
            resetForm();
          }
        } catch (error) {
          if (error instanceof ApiError) {
            message.error(error.message);
          } else {
            message.error(t('level.actions.error.update'));
          }
        } finally {
          loading.value = false;
        }
      },
      onCancel() {}
    });
  } else {
    handleSubmit();
  }
};

const handleSubmit = async () => {
  try {
    loading.value = true;
    
    if (!await validateForm()) {
      return;
    }

    const payload: LevelSetting = {
      ...formState.value,
      websiteId: props.websiteId,
    };

    if (props.isEdit) {
      const success = await levelSettingStore.updateLevel(payload);
      if (success) {
        message.success(t('level.actions.updateSuccess'));
        emit('submit', payload);
        emit('success');
        emit('update:visible', false);
        resetForm();
      }
    } else {
      // Xử lý thêm mới
      try {
        await levelSettingStore.createLevelSetting({
          ...payload,
          levelId: undefined  // Đảm bảo không gửi levelId khi tạo mới
        });
        message.success(t('level.actions.addSuccess'));
        emit('success');
        emit('update:visible', false);
        resetForm();
      } catch (error) {
        if (error instanceof ApiError) {
          message.error(error.message);
        } else {
          message.error(t('level.actions.error.add'));
        }
      }
    }
  } catch (error) {
    if (error instanceof ApiError) {
      message.error(error.message);
    } else {
      message.error(t('level.actions.error.add'));
    }
  } finally {
    loading.value = false;
  }
};

const resetForm = () => {
  formRef.value?.resetFields();
  errors.value = {};
  formState.value = { ...defaultFormState, websiteId: props.websiteId };
};

const handleCancel = () => {
  resetForm();
  emit('update:visible', false);
};

// Watch khi initialData thay đổi để cập nhật formState
watch(
  () => props.initialData,
  (newVal) => {
    if (newVal) {
      formState.value = { ...newVal };
    } else {
      formState.value = { ...defaultFormState, websiteId: props.websiteId };
    }
  },
  { immediate: true, deep: true }
);

// Watch khi visible thay đổi
watch(
  () => props.visible,
  (newVal) => {
    if (newVal && props.isEdit && props.initialData) {
      formState.value = { ...props.initialData };
    }
  }
);
</script>

<style>
/* Override chỉ button primary không phải dangerous */
button.ant-btn.ant-btn-primary:not(.ant-btn-dangerous) {
  -webkit-appearance: none;
  background-color: #1890ff !important;
  background-image: none;
}

/* Ensure modal confirm buttons (không phải dangerous) cũng được override */
.ant-modal-confirm .ant-btn.ant-btn-primary:not(.ant-btn-dangerous),
.ant-modal-footer .ant-btn.ant-btn-primary:not(.ant-btn-dangerous) {
  -webkit-appearance: none;
  background-color: #1890ff !important;
  background-image: none;
}
</style>

